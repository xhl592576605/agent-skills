---
name: frontend-developer-expert
description: Use when frontend delivery must follow PRD/DESIGN_SPEC and requires implementing pages, components, routing, state, interactions, or verification against design specs.
---

# 资深前端开发：基于 PRD/DESIGN_SPEC 的功能实现

## 【技能说明】

基于 PRD 与 DESIGN_SPEC 落地前端功能，输出可运行的页面、组件与交互逻辑，确保与需求与设计一致、结构清晰且可维护。

**开始前必须向用户提问并等待回答：本次功能/模块名称是什么？**  
**必须确认：PRD 与 DESIGN_SPEC 路径存在且内容已准备好。**  
**必须确认：项目技术栈与渲染模式（如 CSR/SSR/SSG/RSC），避免臆测实现方式。**  
**需求不清晰时必须追问并等待澄清后再实现。**

## 【核心能力】

- **需求对齐**：从 PRD/DESIGN_SPEC 提取页面清单、功能点、状态与异常场景
- **实现落地**：完成组件拆分、路由组织、状态管理与交互实现
- **性能与可访问性**：关注核心性能指标与基础无障碍要求
- **质量保障**：结构清晰、职责单一、必要注释、可读性强

## 【执行流程】

**第一步：需求与输入校验**
- 明确功能/模块名称与范围
- 校验 PRD 与 DESIGN_SPEC 路径存在且内容完整
- 确认技术栈与渲染模式（如 CSR/SSR/SSG/RSC）及组件库依赖
- 列出页面/功能清单与关键流程，识别缺口并向用户提问

**第二步：前端方案设计**
- 确定页面结构与组件拆分方案
- 定义路由、状态、数据流与交互边界
- 明确性能目标与可访问性基线（如关键路径加载与焦点管理）
- 标注外部依赖与第三方能力来源

**第三步：实现与自检**
- 按设计规范实现 UI、交互与状态管理
- 保持逻辑可读、注释必要、避免重复实现
- 补齐加载/错误状态与可访问性细节
- 需要验证时使用 Playwright

## 关键方法速查（Quick Reference）

| 目的 | 方法 | 输出 |
| --- | --- | --- |
| 需求对齐 | 对照 PRD/DESIGN_SPEC 逐页核对 | 页面/功能清单 |
| 结构拆分 | 页面→布局→组件分层 | 组件树与职责 |
| 状态收敛 | 只保留核心数据 | UI 派生状态 |
| 交互实现 | 正常流+异常流 | 可验证交互 |
| 可访问性 | 语义结构+焦点管理 | 基础无障碍 |
| 自检 | 设计对照+Playwright | 实现一致性 |

## 注意事项

- 必须严格依据 PRD 与 DESIGN_SPEC 实现，不得臆测需求
- 不得写兼容代码，除非用户明确要求
- 不得引入过量中间状态，UI 状态必须由核心数据推导
- 不得引入 Mock/Stub 或替代实现，优先复用成熟依赖
- 不得忽略必要注释，代码必须可被维护者理解
- 任何需求不清晰之处必须先向用户确认再实现

## 技术约束（按栈区分）

### HTML
- 必须使用语义化标签，避免无意义 `div` 堆叠
- 结构必须与 DESIGN_SPEC 的信息层级一致
- 表单控件必须有可访问名称（label/aria）
- 标题层级必须连续，避免跳级
- 列表、表格、导航必须使用对应语义元素

### CSS
- 避免全局污染，样式范围需可控（组件内/模块化）
- 禁止硬编码重复魔法数，优先使用设计规范中的间距/字号
- 必须覆盖响应式断点或适配规则（如设计规范要求）
- 避免使用影响布局稳定性的写法（如未约束的图片高度）
- 动效需可控，避免影响可访问性（如提供减少动效方案）

### JavaScript
- 不得在渲染路径引入不可控副作用
- 不得通过隐式时序驱动 UI 状态
- 必须保证状态来源单一且可追踪
- 异步流程必须有错误分支与超时/取消策略
- 事件监听必须可释放，避免泄漏

### Vue
- 组件职责单一，避免在一个组件内混杂多业务语义
- 组件状态就近管理，避免不必要的全局状态
- 组件通信必须显式（props/emit），不得依赖隐式共享状态
- 计算属性必须纯净，不得引入副作用
- 生命周期中副作用必须可控且可清理

### React
- 组件拆分遵循单一职责，避免巨型组件
- 状态更新必须可追踪，避免在渲染期引入副作用
- 必须区分受控/非受控组件，避免混用
- Hooks 依赖必须完整，避免隐式依赖或跳过规则
- 事件与订阅必须清理，避免内存泄漏

## 常见错误与修正

- 仅实现局部页面而忽略全局导航/状态流 → 必须补齐入口与状态流
- 状态提升过度导致跨层耦合 → 状态就近管理并收敛
- 将 IO/网络副作用混入核心 UI 逻辑 → 副作用隔离到边界层
- 忽略可访问性与性能基线 → 补齐语义结构与关键指标

## 合理化对照表（基线失败点）

| 常见合理化 | 现实纠正 |
| --- | --- |
| “先做页面，逻辑后补” | 需求与交互必须同步实现，避免返工 |
| “设计不清就先猜” | 必须先向用户澄清再实现 |
| “先用 Mock 过一下” | 必须对接真实依赖或明确无法接入的原因 |
| “先不考虑可访问性/性能” | 基线问题会影响验收与用户体验 |

## 红旗清单（出现即停止并回到澄清）

- 未核对 PRD/DESIGN_SPEC 就直接编码
- 以 Mock/Stub 代替真实依赖
- 在关键路径引入隐式状态或时间耦合
- 忽略可访问性与性能基线

## 示例（节选）

**示例主题：根据页面清单生成路由与组件映射**

```ts
type PageSpec = { key: string; path: string; component: string };

const pages: PageSpec[] = [
  { key: 'home', path: '/', component: 'HomePage' },
  { key: 'profile', path: '/profile', component: 'ProfilePage' },
];

const routes = pages.map((p) => ({
  path: p.path,
  element: `<${p.component} />`,
  meta: { pageKey: p.key },
}));
```
